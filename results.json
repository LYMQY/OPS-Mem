[
    {
        "index": 1,
        "question": "You want to sell a kind of item in order to maximize your profit. Market research tells you that if you set the price at $1.50, you will be able to sell 5000 items, and for every 10 cents you lower the price below $1.50 you will be able to sell another 1000 items. You can only reduce the price by a multiple of 10 cents. Suppose that your fixed costs ( “start-up costs” ) total $2000, and the per item cost of production ( “marginal cost” ) is $0.50. Find the price to set per item and the number of items sold in order to maximize profit, and also determine the maximum profit you can get.",
        "answer": 3600,
        "generated_code": "# Define constants\ninitial_price = 1.50\nmax_reduction = 0.50  # Since reducing more than $0.50 would make price negative\nfixed_cost = 2000\nmarginal_cost = 0.50\nitems_per_10_cents = 1000\n\n# Initialize variables to track maximum profit\nmax_profit = -float('inf')\nbest_price = 0\nbest_quantity = 0\n\n# Try all valid prices (from $1.50 to $1.00 by steps of $0.10)\nfor price in range(int(150), int(100), -1):\n    price_dollars = price / 100.0\n    quantity_sold = 5000 + (initial_price - price_dollars) * items_per_10_cents / 0.10\n    quantity_sold = int(quantity_sold)  # Round to integer (since you can't sell a fraction of an item)\n    revenue = price_dollars * quantity_sold\n    cost = marginal_cost * quantity_sold + fixed_cost\n    profit = revenue - cost\n\n    # Update best price and quantity if profit is higher\n    if profit > max_profit:\n        max_profit = profit\n        best_price = price_dollars\n        best_quantity = quantity_sold\n\n# Print the results\nprint('-' * 10)\nprint(f\"Best Price per Item: ${best_price:.2f}\")\nprint(f\"Number of Items Sold: {best_quantity}\")\nprint(f\"Maximum Profit: ${max_profit:.2f}\")"
    },
    {
        "index": 7,
        "question": "A logistics company is managing the distribution of three types of goods: GoodsX, GoodsY, and GoodsZ. The company needs to decide how many trucks to allocate for each type of good and how much to invest in route optimization software to optimize delivery efficiency and minimize costs. The relationship between investment in optimization and cost reduction for each type of good is given in the following Table.\n\n| Goods | Initial Cost per Truck | Cost Reduction per $100 Investment |\n|-------|------------------------|-----------------------------------|\n| GoodsX | $1,000                 | $10                               |\n| GoodsY | $1,200                 | $12                               |\n| GoodsZ | $1,500                 | $15                               |\n\nThe company has a total of 50 trucks available for allocation. The budget for route optimization software is $10,000. Due to contractual obligations, the company must allocate at least 10 trucks for GoodsX and 15 trucks for GoodsY. The company wants to ensure that the total investment in optimization does not exceed the total cost savings from using the software. The company aims to minimize the total delivery cost for all goods.\n",
        "answer": 18000,
        "generated_code": "import math\nfrom ortools.linear_solver import pywraplp\n\n# Create the solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# Define variables\n# Truck allocation\ntX = solver.IntVar(0, 50, 'tX')  # trucks for GoodsX\ntY = solver.IntVar(0, 50, 'tY')  # trucks for GoodsY\ntZ = solver.IntVar(0, 50, 'tZ')  # trucks for GoodsZ\n\n# Investment in optimization (in increments of $100, i.e., invX = 1 means $100 invested)\ninvX = solver.IntVar(0, 100, 'invX')  # $100 increments for GoodsX\ninvY = solver.IntVar(0, 100, 'invY')  # $100 increments for GoodsY\ninvZ = solver.IntVar(0, 100, 'invZ')  # $100 increments for GoodsZ\n\n# Constraint: Total trucks allocated should not exceed 50\nsolver.Add(tX + tY + tZ <= 50)\n\n# Constraint: Minimum trucks for GoodsX and GoodsY\nsolver.Add(tX >= 10)\nsolver.Add(tY >= 15)\n\n# Constraint: Total investment (in $) should not exceed the budget\n# $100 investment = $100 × invX, so total investment is 100 × (invX + invY + invZ)\n# Total cost savings for optimization:\n# For each $100 invested in GoodsX, the savings are: $10 × invX\n# Similarly for GoodsY and GoodsZ\ntotal_savings = 10 * invX + 12 * invY + 15 * invZ\ntotal_investment = 100 * (invX + invY + invZ)\n\n# Ensure the investment does not exceed cost savings\nsolver.Add(total_investment <= total_savings)\n\n# Calculate the total delivery cost\ntotal_cost = 1000 * tX + 1200 * tY + 1500 * tZ\n\n# Set the objective to minimize total delivery cost\nsolver.Minimize(total_cost)\n\n# Solve the problem\nstatus = solver.Solve()\n\n# Print the results\nprint('-' * 10)\nif status == pywraplp.Solver.OPTIMAL:\n    print(f\"Trucks allocated to GoodsX: {tX.solution_value()}\")\n    print(f\"Trucks allocated to GoodsY: {tY.solution_value()}\")\n    print(f\"Trucks allocated to GoodsZ: {tZ.solution_value()}\")\n    print(f\"Optimal investment in optimization: ${100 * (invX.solution_value() + invY.solution_value() + invZ.solution_value())}\")\n    print(f\"Minimum Total Delivery Cost: ${total_cost.solution_value()}\")\nelse:\n    print(\"The problem could not be solved to optimality.\")"
    },
    {
        "index": 5,
        "question": "There are six cities (cities 1-6) in Kilroy County. The county must determine where to build fire stations. The county wants to build the minimum number of fire stations needed to ensure that at least one fire station is within 15 minutes (driving time) of each city. The times (in minutes) required to drive between the cities in Kilroy County are shown in Table 6: \nTime Required to Travel between Cities in Kilroy County, \nFrom City 1 to ctiy 1-6 are 0 10 20 30 30 20; \nFrom City 2 to ctiy 1-6 are 10 0 25 35 20 10;  \nFrom City 3 to ctiy 1-6 are 20 25 0 15 30 20; \nFrom City 4 to ctiy 1-6 are 30 35 15 0 15 25; \nFrom City 5 to ctiy 1-6 are 30 20 30 15 0 14; \nFrom City 5 to ctiy 1-6 are 20 10 20 25 14 0. \nFormulate an linear problem that will tell Kilroy how many fire stations should be built and where they should be located.",
        "answer": 0,
        "generated_code": "import math\nfrom ortools.linear_solver import pywraplp\n\n# Create a solver using SCIP as the backend solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# Define the driving time matrix\n# Rows are from cities, columns are to cities\ndriving_times = [\n    [0, 10, 20, 30, 30, 20],  # City 1 to others\n    [10, 0, 25, 35, 20, 10],  # City 2 to others\n    [20, 25, 0, 15, 30, 20],  # City 3 to others\n    [30, 35, 15, 0, 15, 25],  # City 4 to others\n    [30, 20, 30, 15, 0, 14],  # City 5 to others\n    [20, 10, 20, 25, 14, 0]   # City 6 to others\n]\n\n# Create binary variables for each city (i.e., whether to build a fire station)\nx = [solver.IntVar(0, 1, 'x_%d' % i) for i in range(6)]\n\n# Objective: Minimize the number of fire stations\nobjective = solver.Objective()\nfor i in range(6):\n    objective.SetCoefficient(x[i], 1)\nobjective.SetMinimization()\n\n# Constraints: At least one fire station within 15 minutes of each city\nfor j in range(6):\n    constraint = solver.Constraint(1, solver.infinity())\n    for i in range(6):\n        if driving_times[i][j] <= 15:\n            constraint.SetCoefficient(x[i], 1)\n\n# Solve the problem\nstatus = solver.Solve()\n\n# Output the solution\nprint('-' * 10)\nif status == pywraplp.Solver.OPTIMAL:\n    print(\"Optimal solution found!\")\n    for i in range(6):\n        print(f\"Fire station in city {i+1}:\", \"Yes\" if x[i].solution_value() == 1 else \"No\")\n    print(\"Total number of fire stations:\", sum(x[i].solution_value() for i in range(6)))\nelse:\n    print(\"The problem could not be solved to optimality.\")"
    },
    {
        "index": 9,
        "question": "Of all rectangles of area 100, which has the smallest perimeter?",
        "answer": 40,
        "generated_code": "import math\nfrom ortools.linear_solver import pywraplp\n\n# Create a solver using SCIP as the backend solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# Define variables (assuming integer side lengths, for more general use)\nx = solver.IntVar(1, solver.infinity(), 'x')  # side length x\ny = solver.IntVar(1, solver.infinity(), 'y')  # side length y\n\n# Add the area constraint: x * y = 100\n# Since it's an equality constraint, we need to use the == operator\nsolver.Add(x * y == 100)\n\n# Define the objective: minimize the perimeter\n# Perimeter is 2*(x + y)\nsolver.Minimize(2 * (x + y))\n\n# Solve the problem\nstatus = solver.Solve()\n\n# Print the optimal solution (value of the variables & the objective)\nprint('-' * 10)\nif status == pywraplp.Solver.OPTIMAL:\n    print(\"Side length x:\", x.solution_value())\n    print(\"Side length y:\", y.solution_value())\n    print(\"Minimum Perimeter:\", solver.Objective().Value())\nelse:\n    print(\"The problem could not be solved to optimality.\")"
    },
    {
        "index": 10,
        "question": "A golf course is hosting an event and can transport guests using either golf carts or pull carts. A golf cart can take 4 guests while a pull cart can take 1 guest. Since golf carts take up a lot of space, at most 60% of carts can be golf carts. If the golf course needs to transport at least 80 guests, how many of each cart should be used to minimize the total number of carts needed?",
        "answer": 29,
        "generated_code": "import math\nfrom ortools.linear_solver import pywraplp\n\n# Create a solver using SCIP as the backend solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# Define decision variables\nG = solver.IntVar(0, solver.infinity(), 'Golf carts')  # number of golf carts\nP = solver.IntVar(0, solver.infinity(), 'Pull carts')  # number of pull carts\n\n# Define the objective function\n# We want to minimize the total number of carts: G + P\nsolver.Minimize(G + P)\n\n# Add constraints\n# 1. At least 80 guests must be transported\n# 2. At most 60% of the total carts can be golf carts → 2G <= 3P\n# 3. Non-negativity constraint (number of carts must be non-negative)\n\nsolver.Add(4 * G + P >= 80)\nsolver.Add(2 * G <= 3 * P)\n\n# Solve the problem\nstatus = solver.Solve()\n\n# Print the optimal solution (value of the variables & the objective)\nprint('-' * 10)\nif status == pywraplp.Solver.OPTIMAL:\n    print(\"Number of Golf Carts:\", G.solution_value())\n    print(\"Number of Pull Carts:\", P.solution_value())\n    print(\"Minimum Total Carts:\", solver.Objective().Value())\nelse:\n    print(\"The problem could not be solved to optimality.\")"
    },
    {
        "index": 11,
        "question": "To graduate from Basketweavers University with a major in operations research, a student must complete at least two math courses, at least two OR courses, and at least two computer courses. Some courses can be used to fulfill more than one requirement: Calculus can fulfill the math requirement; operations research, math and OR requirements; data structures, computer and math requirements; business statistics, math and OR requirements; computer simulation, OR and computer requirements; introduction to computer programming, computer requirement; and forecasting, OR and math requirements. Some courses are prerequisites for others: Calculus is a prerequisite for business statistics; introduction to computer programming is a prerequisite for computer simulation and for data structures; and business statistics is a prerequisite for forecasting. Minimizes the number of courses needed to satisfy the major requirements.",
        "answer": 4,
        "generated_code": "# The list of courses with their requirements and prerequisites\ncourses = {\n    'Calculus': {'Math': True, 'OR': False, 'Computer': False, 'prereq': []},\n    'Data Structures': {'Math': True, 'OR': False, 'Computer': True, 'prereq': ['Introduction to Computer Programming']},\n    'Forecasting': {'Math': True, 'OR': True, 'Computer': True, 'prereq': ['Business Statistics']},\n    'Business Statistics': {'Math': True, 'OR': True, 'Computer': False, 'prereq': ['Calculus']},\n    'Operations Research': {'Math': True, 'OR': True, 'Computer': False, 'prereq': []},\n    'Computer Simulation': {'Math': False, 'OR': True, 'Computer': True, 'prereq': ['Introduction to Computer Programming']},\n    'Introduction to Computer Programming': {'Math': False, 'OR': False, 'Computer': True, 'prereq': []}\n}\n\n# Define requirements\nrequired_math = 2\nrequired_or = 2\nrequired_computer = 2\n\n# Iterate through all combinations of courses to find the minimal set that meets the requirements\nfrom itertools import combinations, chain\nimport copy\n\n# Collect all courses as a list for iteration\nall_courses = list(courses.keys())\n\nmin_courses = float('inf')\nbest_combination = []\n\n# Try all combinations of courses from size 2 to 6\nfor num_courses in range(2, 7):\n    for combo in combinations(all_courses, num_courses):\n        # Create a copy of the courses & their requirements\n        course_subjects = {c: courses[c] for c in combo}\n        \n        # Track if prerequisites are met\n        taken = {c: False for c in combo}\n        for course in combo:\n            if courses[course]['prereq']:\n                for prereq in courses[course]['prereq']:\n                    if prereq not in combo:\n                        taken[course] = False\n                        break\n                else:\n                    taken[course] = True\n\n        # Check if all prerequisites are met\n        if all(taken.values()):\n            # Count math, OR, and computer requirements\n            math_count = sum(course_subjects[c]['Math'] for c in combo)\n            or_count = sum(course_subjects[c]['OR'] for c in combo)\n            computer_count = sum(course_subjects[c]['Computer'] for c in combo)\n\n            # Check if requirements are met\n            if math_count >= required_math and or_count >= required_or and computer_count >= required_computer:\n                # Check if the combination is valid and has fewer courses than the current minimum\n                if num_courses < min_courses:\n                    min_courses = num_courses\n                    best_combination = combo\n\nprint(\"Minimal number of courses needed:\", min_courses)\nprint(\"Best combination of courses:\", best_combination)"
    },
    {
        "index": 12,
        "question": "A man on a strict diet only drinks meal replacement drinks from two brands, alpha and omega. The alpha brand drink contains 30 grams of protein, 20 grams of sugar, and 350 calories per bottle. The omega brand drink contains 20 grams of protein, 15 grams of sugar, and 300 calories per bottle. The man wants to get at least 100 grams of protein and 2000 calories. In addition, because the omega brand drink contains tiny amounts of caffeine, at most 35% of the drink should be omega brand. How many bottles of each should he drink to minimize his sugar intake?",
        "answer": 110,
        "generated_code": "import math\nfrom ortools.linear_solver import pywraplp\n\n# Create a solver using SCIP as the backend\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# Define variables\nAlpha = solver.IntVar(0, solver.infinity(), 'Alpha')  # number of alpha drinks\nOmega = solver.IntVar(0, solver.infinity(), 'Omega')  # number of omega drinks\n\n# Add constraints\n\n# Constraint 1: At least 100g of protein\n# Each alpha drink gives 30g protein, each omega gives 20g\nsolver.Add(30 * Alpha + 20 * Omega >= 100)\n\n# Constraint 2: At least 2000 calories\n# Each alpha drink is 350 calories, each omega is 300 calories\nsolver.Add(350 * Alpha + 300 * Omega >= 2000)\n\n# Constraint 3: Omega can be at most 35% of the total drinks\n# This means Omega <= 0.35 * (Alpha + Omega)\n# Rearrange to: 0.65 * Omega <= 0.35 * Alpha\n# Which simplifies to: 0.35 * Alpha - 0.65 * Omega >= 0\n# To avoid floating point issues, we can multiply both sides by 100 and rewrite\n# So: 35 * Alpha - 65 * Omega >= 0\nsolver.Add(35 * Alpha - 65 * Omega >= 0)\n\n# Define the objective function to minimize total sugar\n# Each alpha drink has 20g sugar, each omega has 15g\nsolver.Minimize(20 * Alpha + 15 * Omega)\n\n# Solve the problem\nstatus = solver.Solve()\n\n# Print the results\nprint('-' * 10)\nif status == pywraplp.Solver.OPTIMAL:\n    print(\"Number of Alpha drinks:\", Alpha.solution_value())\n    print(\"Number of Omega drinks:\", Omega.solution_value())\n    print(\"Minimum Sugar Intake:\", solver.Objective().Value(), \"grams\")\nelse:\n    print(\"The problem could not be solved to optimality.\")"
    },
    {
        "index": 13,
        "question": "A fashion company sells regular handbags and premium handbags made of higher quality material. They can sell regular handbags at a profit of $30 each and premium handbags at a profit of $180 each. The total monthly cost of manufacturing is $200 per regular handbag and $447 per premium handbag. The company has a total budget of $250000 and can sell at most 475 handbags of either type per month. How many of each handbag should they sell to maximize its monthly profit?",
        "answer": 85500,
        "generated_code": "import math\nfrom ortools.linear_solver import pywraplp\n\n# Create a solver using SCIP as the backend solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# Define variables\nregular = solver.IntVar(0, 475, 'Regular')  # number of regular handbags\npremium = solver.IntVar(0, 475, 'Premium')  # number of premium handbags\n\n# Add constraints\n# Constraints: total cost ≤ 250000 and production limits for each type\n# Total monthly cost: 200 * regular + 447 * premium ≤ 250000\nsolver.Add(200 * regular + 447 * premium <= 250000)\n\n# Define objective function: Maximize profit = 30 * regular + 180 * premium\nsolver.Maximize(30 * regular + 180 * premium)\n\n# Solve the problem\nstatus = solver.Solve()\n\n# Print the optimal solution (value of the variables & the objective)\nprint('-' * 10)\nif status == pywraplp.Solver.OPTIMAL:\n    print(\"Number of regular handbags:\", regular.solution_value())\n    print(\"Number of premium handbags:\", premium.solution_value())\n    print(\"Maximized Monthly Profit: \", solver.Objective().Value())\nelse:\n    print(\"The problem could not be solved to optimality.\")"
    },
    {
        "index": 16,
        "question": "A smoothie shop has a promotion for their two smoothies; an acai berry smoothie and a banana chocolate smoothie. It takes 7 units of acai berries and 3 units of water to make the acai berry smoothie. It takes 6 units of banana chocolate and 4 units of water to make the banana chocolate smoothie. Banana chocolate smoothies are more popular and thus the number of banana chocolate smoothies made must be more than the number of acai berry smoothies made. However, the acai berry smoothies have a loyal customer base, and at least 35% of the smoothies made must be acai berry smoothies. If the smoothie shop has 3500 units of acai berries and 3200 units of banana chocolate, to reduce the total amount of water, how many of each smoothie type should be made?",
        "answer": 18,
        "generated_code": "import math\nfrom ortools.linear_solver import pywraplp\n\n# Create a solver using SCIP as the backend\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# Define variables\nA = solver.IntVar(0, solver.infinity(), 'A')  # Acai berry smoothies\nB = solver.IntVar(0, solver.infinity(), 'B')  # Banana chocolate smoothies\n\n# Add constraints\n# Acai berries available: 3500 units\nsolver.Add(7 * A <= 3500)\n# Banana chocolate available: 3200 units\nsolver.Add(6 * B <= 3200)\n# Banana chocolate smoothies must be more than acai berry smoothies: B > A\n# To handle this in integer programming: B >= A + 1\nsolver.Add(B >= A + 1)\n# At least 35% of the smoothies must be acai berry smoothies: A / (A + B) >= 0.35\n# Rearranged: A >= 0.35 * (A + B)\n# Multiply both sides by (A + B) to eliminate the division: A >= 0.35A + 0.35B\n# Simplify: A - 0.35A >= 0.35B => 0.65A >= 0.35B\n# Multiply both sides by 100 to eliminate decimals: 65A >= 35B\n# So, 65A - 35B >= 0\n# In constraints, we use only integers → If we assume the minimum A and B are integers,\n# we can safely use this formulation.\nsolver.Add(65 * A - 35 * B >= 0)\n\n# Objective: Minimize total water used\n# Water for Acai berry smoothie: 3 units per smoothie\n# Water for Banana chocolate smoothie: 4 units per smoothie\n# Total water: 3*A + 4*B\nsolver.Minimize(3 * A + 4 * B)\n\n# Solve the problem\nstatus = solver.Solve()\n\n# Print the optimal solution\nprint('-' * 10)\nif status == pywraplp.Solver.OPTIMAL:\n    print(\"Number of Acai Berry Smoothies:\", A.solution_value())\n    print(\"Number of Banana Chocolate Smoothies:\", B.solution_value())\n    print(\"Minimum Water Usage:\", solver.Objective().Value())\nelse:\n    print(\"The problem could not be solved to optimality.\")"
    },
    {
        "index": 3,
        "question": "There are two ways to extract a metal from mined ores. The first way is to use process J and the second is process P. Process J can extract 5 units of metal using 8 units of water and produces 3 units of pollution. Process P can extract 9 units of metal using 6 units of water and produces 5 units of pollution. There can be at most 1500 units of water 1350 units of pollution. How many of each type of processes should be performed to maximize the amount of metal extracted?",
        "answer": 2250,
        "generated_code": "import math\nfrom ortools.linear_solver import pywraplp\n\n# Create a solver using SCIP as the backend\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# Define variables: number of processes J and P\nJ = solver.IntVar(0, solver.infinity(), 'J')\nP = solver.IntVar(0, solver.infinity(), 'P')\n\n# Add constraints: water and pollution limits\nsolver.Add(8 * J + 6 * P <= 1500)  # Water constraint\nsolver.Add(3 * J + 5 * P <= 1350)  # Pollution constraint\n\n# Define objective: maximize the amount of metal extracted\nsolver.Maximize(5 * J + 9 * P)\n\n# Solve the problem\nstatus = solver.Solve()\n\n# Print the optimal solution\nprint('-' * 10)\nif status == pywraplp.Solver.OPTIMAL:\n    print(\"Number of Process J:\", J.solution_value())\n    print(\"Number of Process P:\", P.solution_value())\n    print(\"Maximized Metal Extracted:\", solver.Objective().Value())\nelse:\n    print(\"The problem could not be solved to optimality.\")"
    },
    {
        "index": 15,
        "question": "A bakery produces five types of cakes: C1, C2, C3, C4, and C5. They need to determine the quantities of each cake to produce. For C2, the revenue per unit is $40, the production time per unit is 2 hours, and the ingredient cost per unit is $15. For C3, the revenue per unit is $50, the production time per unit is 3 hours, and the ingredient cost per unit is $20. For C4, the revenue per unit is $60, the production time per unit is 4 hours, and the ingredient cost per unit is $25. For C5, the revenue per unit is $70, the production time per unit is 5 hours, and the ingredient cost per unit is $30. The bakery has a limited production line and can only produce one cake at a time. The bakery wants to maximize the profit efficiency (profit per hour of production time). The bakery has a limited production time of 80 hours. The bakery has a budget of $3000 for ingredient costs. The bakery has a production capacity of 200 units in terms of the number of units it can produce. Due to market demand, the bakery must produce at least 40 units in total. For C1, the revenue per unit is $30, the production time per unit is 1 hour, and the ingredient cost per unit is $10.",
        "answer": 20,
        "generated_code": "import math\nfrom ortools.linear_solver import pywraplp\n\n# Create a solver using SCIP as the backend\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# Define decision variables: number of cakes to produce\nC1 = solver.IntVar(0, solver.infinity(), 'C1')\nC2 = solver.IntVar(0, solver.infinity(), 'C2')\nC3 = solver.IntVar(0, solver.infinity(), 'C3')\nC4 = solver.IntVar(0, solver.infinity(), 'C4')\nC5 = solver.IntVar(0, solver.infinity(), 'C5')\n\n# Add constraints\n# 1. Production time constraint (total ≤ 80 hours)\nsolver.Add(1 * C1 + 2 * C2 + 3 * C3 + 4 * C4 + 5 * C5 <= 80)\n\n# 2. Ingredient cost constraint (total ≤ $3000)\nsolver.Add(10 * C1 + 15 * C2 + 20 * C3 + 25 * C4 + 30 * C5 <= 3000)\n\n# 3. Total production capacity (total number of cakes ≤ 200 units)\nsolver.Add(C1 + C2 + C3 + C4 + C5 <= 200)\n\n# 4. Minimum total production requirement (at least 40 cakes)\nsolver.Add(C1 + C2 + C3 + C4 + C5 >= 40)\n\n# Calculate total profit (numerator) = sum of (revenue - ingredient cost) per cake\ntotal_profit = (30 - 10) * C1 + (40 - 15) * C2 + (50 - 20) * C3 + (60 - 25) * C4 + (70 - 30) * C5\n\n# Calculate total production time (denominator)\ntotal_time = 1 * C1 + 2 * C2 + 3 * C3 + 4 * C4 + 5 * C5\n\n# Set the objective: Maximize total profit\nsolver.Maximize(total_profit)\n\n# Solve the problem\nstatus = solver.Solve()\n\n# Print the optimal solution\nprint('-' * 10)\nif status == pywraplp.Solver.OPTIMAL:\n    print(\"Optimal solution found.\")\n    print(\"Number of C1:\", C1.solution_value())\n    print(\"Number of C2:\", C2.solution_value())\n    print(\"Number of C3:\", C3.solution_value())\n    print(\"Number of C4:\", C4.solution_value())\n    print(\"Number of C5:\", C5.solution_value())\n    \n    # Calculate total profit and total time\n    profit = total_profit.solution_value()\n    time = total_time.solution_value()\n    profit_rate = profit / time if time > 0 else 0\n    \n    print(\"Total Profit:\", profit)\n    print(\"Total Production Time (hours):\", time)\n    print(\"Profit Efficiency (profit per hour):\", profit_rate)\nelse:\n    print(\"The problem could not be solved to optimality.\")"
    },
    {
        "index": 18,
        "question": "A telecommunications company installs internet service and TV service in buildings. Each internet service takes 60 minutes of wiring time and 10 minutes of box installation time. Each TV service takes 50 minutes of wiring time and 20 minutes of box installation time. The company has available 7000 minutes of wiring time and 4000 minutes of box installation time. If the profit per internet service installation is $100 and the profit per TV service installation is $120, how many of each should be installed to maximize profit?",
        "answer": 16800,
        "generated_code": "import math\nfrom ortools.linear_solver import pywraplp\n\n# Create a solver using SCIP as the backend solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# Define variables\nInt = solver.IntVar(0, solver.infinity(), 'Int')  # Number of internet services\nTV = solver.IntVar(0, solver.infinity(), 'TV')   # Number of TV services\n\n# Add constraints\n# 1. Wiring time: 60 minutes per internet service, 50 per TV service. Total wiring time should be ≤ 7000 minutes.\nsolver.Add(60 * Int + 50 * TV <= 7000)\n\n# 2. Box installation time: 10 minutes per internet service, 20 per TV service. Total time ≤ 4000 minutes.\nsolver.Add(10 * Int + 20 * TV <= 4000)\n\n# Define objective function: Maximize total profit = 100 * Int + 120 * TV\nsolver.Maximize(100 * Int + 120 * TV)\n\n# Solve the problem\nstatus = solver.Solve()\n\n# Print the optimal solution (value of the variables & the objective)\nprint('-' * 10)\nif status == pywraplp.Solver.OPTIMAL:\n    print(\"Number of Internet Services:\", Int.solution_value())\n    print(\"Number of TV Services:\", TV.solution_value())\n    print(\"Maximized Total Profit: $\", solver.Objective().Value())\nelse:\n    print(\"The problem could not be solved to optimality.\")"
    },
    {
        "index": 20,
        "question": "Find the dimensions of the rectangle of largest area having fixed perimeter 100.",
        "answer": 625,
        "generated_code": "import math\nfrom ortools.linear_solver import pywraplp\n\n# Create a solver using SCIP as the backend\n# For a continuous problem, we can use a linear solver, but this is a quadratic optimization\n# So, we will approach it as a linear programming problem with a variable substitution\n# Let x = length, y = width\n# Replace y with (50 - x) (from the perimeter constraint 2x + 2y = 100)\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# Define variables\nx = solver.NumVar(0, 50, 'x')  # x can be between 0 and 50\ny = solver.NumVar(0, 50, 'y')  # y can be between 0 and 50\n\n# Add constraint: 2x + 2y = 100 => x + y = 50\nsolver.Add(x + y == 50)\n\n# Define objective function: maximize area = x * y\nobjective = solver.Objective()\nobjective.SetCoefficient(x, y.solution_value())  # But we can't use solution_value before solving\nobjective.SetCoefficient(y, x.solution_value()) \n\nobjective.SetMaximization()\n\n# Alternatively, since y can be rewritten as 50 - x, we can directly plug it in\n# To avoid using solution values (which is not allowed yet), use a substitution:\n# The area expression becomes A = x * (50 - x) = 50x - x^2\n# So redefine objective as 50x - x^2 (we'll use x as only variable)\n# But since OR-Tools doesn't work with nonlinear objective functions directly, we need to consider another way.\n\n# To handle this, we will use a **parametric objective** that depends on the constraint solution.\n# Let's reframe the problem to choose x, then compute y, and\n# maximize x * y = x * (50 - x) = 50x - x^2\n\n# Create optimization model\n\n# Since we are maximizing 50x - x^2 (a function of x), if we use variables x and y with the constraint x + y = 50,\n# then the optimization is redundant because the objective becomes linear in terms of x once y is fixed.\n\n# Reimplementation using only x variable, as y = 50 - x\nx2 = solver.NumVar(0, 50, 'x2')\ny2 = solver.NumVar(0, 50, 'y2')\n# Enforce the constraint x2 + y2 = 50\nsolver.Add(x2 + y2 == 50)\n\n# Objective: maximize area x2 * y2 = x2 * (50 - x2) = 50x2 - x2^2\n# OR-Tools works best with linear objectives, but since this is a nonlinear function,\n# we can rework it by maximizing the linear function 50x2 - x2 * y2.\n# However, it's better to just maximize x * y in this specific case.\n\n# Using a nonlinear objective function directly:\n# This is a workaround in OR-Tools, as it's not designed for nonlinear problems natively\n# We can still use this with some assumptions\n\n# So, we'll approach this using a **custom objective**, though this is not the optimal approach due to solver limitations\n# Instead, better is to approach mathematically to find that x = y = 25\n\nprint('-' * 10)\nstatus = solver.Solve()\n\nif status == pywraplp.Solver.OPTIMAL:\n    x_val = x2.solution_value()\n    y_val = y2.solution_value()\n    area = x_val * y_val\n    print(\"Length (x):\", x_val)\n    print(\"Width (y):\", y_val)\n    print(\"Maximized Area:\", area)\nelse:\n    print(\"The problem could not be solved to optimality.\")"
    },
    {
        "index": 8,
        "question": "Jacob has $3000 to invest. He has decided to invest in his favorite clothing company and his favorite tech company. He has decided that the money invested in his favorite clothing company must be at least four times as much as the amount invested in his favorite tech company. He has also limited himself to invest at most $500 in his favorite tech company. If the money invested in his favorite clothing company earns 7% and the money invested in his favorite tech company earns 10%, how much should he invest in each to maximize his profit?",
        "answer": 225,
        "generated_code": "import math\nfrom ortools.linear_solver import pywraplp\n\n# Create a solver using SCIP as the backend\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# Define variables (using IntVar as per the examples)\nclothing = solver.IntVar(0, solver.infinity(), 'Clothing')\ntech = solver.IntVar(0, 500, 'Tech')\n\n# Add constraints\n# 1. Total investment is $3000\nsolver.Add(clothing + tech == 3000)\n# 2. Clothing investment is at least four times tech\nsolver.Add(clothing >= 4 * tech)\n\n# Define objective function: maximize profit\n# Profit = (clothing * 0.07) + (tech * 0.10)\nsolver.Maximize(0.07 * clothing + 0.10 * tech)\n\n# Solve the problem\nstatus = solver.Solve()\n\n# Print the optimal solution\nprint('-' * 10)\nif status == pywraplp.Solver.OPTIMAL:\n    print(\"Clothing Investment: $\", clothing.solution_value())\n    print(\"Tech Investment: $\", tech.solution_value())\n    print(\"Maximized Daily Profit: $\", solver.Objective().Value())\nelse:\n    print(\"The problem could not be solved to optimality.\")"
    },
    {
        "index": 6,
        "question": "A milk tea shop has 50000 ml of milk to make two milk teas: black milk tea and green milk tea. A bottle of black milk tea contains 300 ml of milk while a bottle of green milk tea has 200 ml of milk. The shop knows that they need to make at least three times the number of bottles of black milk tea than green milk tea. They also know that they need to make at least 10 bottles of green milk tea. Each bottle of black milk tea is sold for a profit of $2.5 and each bottle of green milk tea is sold for a profit of $7. How many of each type of milk tea needs to be made in order to maximize profit?",
        "answer": 655,
        "generated_code": "import math\nfrom ortools.linear_solver import pywraplp\n\n# Create a solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# Define integer decision variables\nB = solver.IntVar(0, solver.infinity(), 'B')  # number of black milk tea bottles\nG = solver.IntVar(0, solver.infinity(), 'G')  # number of green milk tea bottles\n\n# Add the constraints\n# 1. Total milk should not exceed 50000 ml\nsolver.Add(300 * B + 200 * G <= 50000)\n\n# 2. Number of black milk tea bottles must be at least 3 times green milk tea\nsolver.Add(B >= 3 * G)\n\n# 3. At least 10 green milk tea bottles must be made\nsolver.Add(G >= 10)\n\n# Define the objective function: maximize profit\n# Profit = $2.5 * B + $7 * G\nprofit = 2.5 * B + 7 * G\nsolver.Maximize(profit)\n\n# Solve the problem\nstatus = solver.Solve()\n\n# Print the optimal solution\nprint('-' * 10)\nif status == pywraplp.Solver.OPTIMAL:\n    print(f\"Number of black milk tea bottles: {B.solution_value()}\")\n    print(f\"Number of green milk tea bottles: {G.solution_value()}\")\n    print(f\"Maximized Daily Profit: ${profit.solution_value():.2f}\")\nelse:\n    print(\"The problem could not be solved to optimality.\")"
    },
    {
        "index": 17,
        "question": "A chicken farmer has sold his chicken and they need to be transported either by bus or by car. A bus can take 100 chicken and takes 2 hours per trip. A car can take 40 chicken and takes 1.5 hours per trip. There can be at most 10 bus trips and at least 60% of the trips must be by car. If the farmer needs to transport 1200 chicken, how many trips of each should be done to minimize the total time needed to transport the chicken?",
        "answer": 34.5,
        "generated_code": "import math\nfrom ortools.linear_solver import pywraplp\n\n# Create a solver using SCIP\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# Define integer variables for bus and car trips\nB = solver.IntVar(0, 10, 'BusTrips')  # B ≤ 10\nC = solver.IntVar(0, solver.infinity(), 'CarTrips')\n\n# Add constraints\n# 1. Total number of chickens = 1200\nconstraint_total = solver.Constraint(1200, 1200)\nconstraint_total.SetCoefficient(B, 100)\nconstraint_total.SetCoefficient(C, 40)\n\n# 2. Maximum number of bus trips allowed (B ≤ 10)\nconstraint_b_max = solver.Constraint(0, 10)\nconstraint_b_max.SetCoefficient(B, 1)\n\n# 3. 60% of total trips must be by car (C ≥ 1.5B)\nconstraint_60pct = solver.Constraint(0, solver.infinity())\nconstraint_60pct.SetCoefficient(C, 2)\nconstraint_60pct.SetCoefficient(B, -3)\n\n# 4. Non-negative variables\n# Already implied by the lower bounds in definition of B and C\n\n# Objective: minimize total time\nsolver.Minimize(2 * B + 1.5 * C)\n\n# Solve the problem\nstatus = solver.Solve()\n\nprint('-' * 10)\nif status == pywraplp.Solver.OPTIMAL:\n    print(\"Optimal Solution Found\")\n    print(\"Number of Bus Trips:\", B.solution_value())\n    print(\"Number of Car Trips:\", C.solution_value())\n    print(\"Minimum Total Time:\", solver.Objective().Value())\nelse:\n    print(\"No optimal solution found.\")"
    },
    {
        "index": 4,
        "question": "A rectangular garden is to be constructed using a rock wall as one side of the garden and wire fencing for the other three sides. Given 100ft of wire fencing, determine the dimensions that would create a garden of maximum area. What is the maximum area?",
        "answer": 1250,
        "generated_code": "dA/dy = 100 - 4y"
    },
    {
        "index": 14,
        "question": "A man is trapped in a swamp at the location: (3/4,0). The swamp is a curve that y >= x^2, and x >= 0. The rescue team must stay as close to him as possible so that they can pass a rope to him. Find the BEST LOCATION of the rope required to rescue him.",
        "answer": 0.35,
        "generated_code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef objective(params):\n    x, y = params\n    return (x - 0.75)**2 + (y - 0)**2  # squared distance to the point (0.75, 0)\n\n# Constraint: y >= x^2\ndef constraint(x_y):\n    x, y = x_y\n    return y - x**2  # y >= x^2\n\n# Initial guess\ninitial_guess = [0.5, 0.25]\n\n# Set bounds\nbounds = [(0, np.inf), (0, np.inf)]\n\n# Constraints as a list\ncons = {'type': 'ineq', 'fun': constraint}\n\n# Perform the minimization\nresult = minimize(objective, initial_guess, bounds=bounds, constraints=cons)\n\n# Print the results\noptimal_x = result.x[0]\noptimal_y = result.x[1]\nmin_distance_squared = result.fun\nmin_distance = np.sqrt(min_distance_squared)\n\nprint(\"Best location for the rope:\", (optimal_x, optimal_y))\nprint(\"Minimum distance from the man:\", min_distance)"
    },
    {
        "index": 2,
        "question": "A logistics company is managing the distribution of three types of goods: GoodsX, GoodsY, and GoodsZ. The company needs to determine the number of trucks allocated to each type of goods and the number of trips per truck for each type of goods will make in the upcoming month. For ease of management, the number of trips per truck is the same for all trucks of the same type of goods. Additionally, the company wants to invest in fuel-efficient upgrades of trucks for each type of goods, which will reduce fuel costs per trip. The company has a total of 50 trucks available for the month. The total investment in fuel efficiency upgrades cannot exceed $60,000. Due to operational constraints, each truck can make no more than 20 trips in the month. The company must ensure that at least 10 trucks are allocated to GoodsX and 15 trucks to GoodsY. The fuel cost per trip for each type of goods decreases by $10 for every $10,000 invested in fuel efficiency upgrades for that type of goods. The initial fuel cost per trip for GoodsX is $200, for GoodsY is $250, and for GoodsZ is $300. The revenue generated per trip is $500 for GoodsX, $600 for GoodsY, and $700 for GoodsZ. The company aims to maximize the total profit from all goods.",
        "answer": 395000,
        "generated_code": "import math\nfrom ortools.linear_solver import pywraplp\n\n# Create a solver using SCIP as the backend solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# Define variables\n# Number of trucks allocated to each type of good (must be integers)\ntx = solver.IntVar(10, 50, 'tx')  # at least 10 trucks for GoodsX\nty = solver.IntVar(15, 50, 'ty')  # at least 15 trucks for GoodsY\ntz = solver.IntVar(0, 50, 'tz')   # no constraint on GoodsZ\n\n# Investment in fuel efficiency upgrades for each type (in thousands of dollars)\ninvx = solver.NumVar(0, 60, 'invx')  # investment for GoodsX\ninvy = solver.NumVar(0, 60, 'invy')  # investment for GoodsY\ninvz = solver.NumVar(0, 60, 'invz')  # investment for GoodsZ\n\n# The number of trips per truck for each type (must be an integer)\ntrips_per_truck_x = solver.IntVar(1, 20, 'trips_per_truck_x')\ntrips_per_truck_y = solver.IntVar(1, 20, 'trips_per_truck_y')\ntrips_per_truck_z = solver.IntVar(1, 20, 'trips_per_truck_z')\n\n# Total trucks: tx + ty + tz <= 50\nsolver.Add(tx + ty + tz <= 50)\n\n# Total investment in upgrades: invx + invy + invz <= 60 (in thousands of dollars)\nsolver.Add(invx + invy + invz <= 60)\n\n# Each truck can make at most 20 trips for all types (this is already modeled by trips_per_truck_x, y, z)\n\n# Define fuel cost per trip after upgrades\nfuel_cost_x = 200 - (invx * 10)  # each $10,000 invested reduces cost by $10\nfuel_cost_y = 250 - (invy * 10)\nfuel_cost_z = 300 - (invz * 10)\n\n# Total revenue for each good\nrevenue_x = 500 * tx * trips_per_truck_x\nrevenue_y = 600 * ty * trips_per_truck_y\nrevenue_z = 700 * tz * trips_per_truck_z\n\n# Total fuel cost for each good\ncost_x = fuel_cost_x * tx * trips_per_truck_x\ncost_y = fuel_cost_y * ty * trips_per_truck_y\ncost_z = fuel_cost_z * tz * trips_per_truck_z\n\n# Total profit = Revenue - Fuel Cost\ntotal_profit = revenue_x + revenue_y + revenue_z - cost_x - cost_y - cost_z\n\n# Objective: Maximize total profit\nsolver.Maximize(total_profit)\n\n# Solve the problem\nstatus = solver.Solve()\n\n# Print the optimal solution\nprint('-' * 15)\nif status == pywraplp.Solver.OPTIMAL:\n    print(f\"Optimal number of trucks for GoodsX: {tx.solution_value()}\")\n    print(f\"Optimal number of trucks for GoodsY: {ty.solution_value()}\")\n    print(f\"Optimal number of trucks for GoodsZ: {tz.solution_value()}\")\n    print(f\"Optimal number of trips per truck for GoodsX: {trips_per_truck_x.solution_value()}\")\n    print(f\"Optimal number of trips per truck for GoodsY: {trips_per_truck_y.solution_value()}\")\n    print(f\"Optimal number of trips per truck for GoodsZ: {trips_per_truck_z.solution_value()}\")\n    print(f\"Optimal investment in GoodX upgrades: ${invx.solution_value() * 1000}\")\n    print(f\"Optimal investment in GoodY upgrades: ${invy.solution_value() * 1000}\")\n    print(f\"Optimal investment in GoodZ upgrades: ${invz.solution_value() * 1000}\")\n    print(f\"Total Profit: ${total_profit.solution_value()}\")\nelse:\n    print(\"The problem could not be solved to optimality.\")"
    },
    {
        "index": 19,
        "question": "A manufacturing company produces three types of electronic devices: smartphones, tablets, and laptops. The company has four different production lines, each with varying efficiency and capacity. On production line 1, each worker produces 10 smartphones, 5 tablets, and 3 laptops per hour. On production line 2, each worker produces 8 smartphones, 6 tablets, and 4 laptops per hour. On production line 3, each worker produces 6 smartphones, 7 tablets, and 5 laptops per hour. On production line 4, each worker produces 5 smartphones, 8 tablets, and 6 laptops per hour. The company needs to produce at least 1000 smartphones, 800 tablets, and 600 laptops daily. The production lines can only be operated or shut down at the same time. Determine the minimum number of hours needed to meet the daily demand. There are a total of 50 workers available. Each production line can be staffed by up to 20 workers at a time. The company wants to ensure that at least one production line is fully staffed (20 workers) if it is operational. Each production line has different productivity rates for each device.",
        "answer": 2.69,
        "generated_code": "import math\nfrom ortools.linear_solver import pywraplp\n\n# Create a solver using SCIP as the backend\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# Define variables\n# x1, x2, x3, x4: binary variables (0 or 1) if the line is operational\nx1 = solver.BoolVar('x1')  # line 1 is used?\nx2 = solver.BoolVar('x2')  # line 2 is used?\nx3 = solver.BoolVar('x3')  # line 3 is used?\nx4 = solver.BoolVar('x4')  # line 4 is used?\n\n# Number of hours each line is run\nt1 = solver.NumVar(0, solver.infinity(), 't1')\nt2 = solver.NumVar(0, solver.infinity(), 't2')\nt3 = solver.NumVar(0, solver.infinity(), 't3')\nt4 = solver.NumVar(0, solver.infinity(), 't4')\n\n# Objective: minimize total hours\ntotal_hours = t1 + t2 + t3 + t4\nsolver.Minimize(total_hours)\n\n# Constraints: each line can run at most 20 workers * hours\n# Line 1 constraint (must run at full capacity if used)\nsolver.Add(t1 <= 20 * x1)\n# Line 2 constraint (must run at full capacity if used)\nsolver.Add(t2 <= 20 * x2)\n# Line 3 constraint (must run at full capacity if used)\nsolver.Add(t3 <= 20 * x3)\n# Line 4 constraint (must run at full capacity if used)\nsolver.Add(t4 <= 20 * x4)\n\n# Total workers can't exceed 50\nsolver.Add(20 * (x1 + x2 + x3 + x4) <= 50)\n\n# Production requirements:\n# Each line produces:\n# Line 1: 10 smartphones, 5 tablets, 3 laptops per hour\n# Line 2: 8 smartphones, 6 tablets, 4 laptops per hour\n# Line 3: 6 smartphones, 7 tablets, 5 laptops per hour\n# Line 4: 5 smartphones, 8 tablets, 6 laptops per hour\n\n# Smartphone production requirement\nsolver.Add(10 * t1 + 8 * t2 + 6 * t3 + 5 * t4 >= 1000)\n# Tablet production requirement\nsolver.Add(5 * t1 + 6 * t2 + 7 * t3 + 8 * t4 >= 800)\n# Laptop production requirement\nsolver.Add(3 * t1 + 4 * t2 + 5 * t3 + 6 * t4 >= 600)\n\n# Solve the problem\nstatus = solver.Solve()\n\n# Print the optimal solution\nprint('-' * 10)\nif status == pywraplp.Solver.OPTIMAL:\n    print(\"Minimum total hours required:\", solver.Objective().Value())\n    print(\"Hours per line:\")\n    print(\"  Line 1:\", t1.solution_value())\n    print(\"  Line 2:\", t2.solution_value())\n    print(\"  Line 3:\", t3.solution_value())\n    print(\"  Line 4:\", t4.solution_value())\n    print(\"Lines used:\")\n    print(\"  Line 1:\", x1.solution_value())\n    print(\"  Line 2:\", x2.solution_value())\n    print(\"  Line 3:\", x3.solution_value())\n    print(\"  Line 4:\", x4.solution_value())\nelse:\n    print(\"The problem could not be solved to optimality.\")"
    }
]